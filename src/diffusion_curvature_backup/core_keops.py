# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/library/Core PyKeops.ipynb.

# %% auto 0
__all__ = ['lazy_distance_matrix', 'lazy_gaussian_kernel', 'lazy_diffusion_matrix', 'phate_distances']

# %% ../../nbs/library/Core PyKeops.ipynb 7
import torch
from pykeops.torch import LazyTensor
def lazy_distance_matrix(
    X,
    use_cuda = torch.cuda.is_available(),
    ):
    X = torch.tensor(X, dtype=torch.float32, device = torch.device('cuda' if use_cuda else 'cpu'))
    x_i = LazyTensor(X[:, None, :])  # (N, 1, D) LazyTensor
    y_j = LazyTensor(X[None, :, :])  # (1, N, D) LazyTensor
    D_ij = ((x_i - y_j) ** 2).sum(-1).sqrt()
    return D_ij

# %% ../../nbs/library/Core PyKeops.ipynb 13
def lazy_gaussian_kernel(
        X,
        kernel_type = "fixed",
        sigma:float = 1, # if fixed, uses kernel bandwidth sigma. If not set, uses a heuristic to estimate a good sigma value
        k:float = 10, # if adaptive, creates a different kernel bandwidth for each point, based on the distance from that point to the kth nearest neighbor
        anisotropic_density_normalization:float = 0.5, # if nonzero, performs anisotropic density normalization
        use_cuda = torch.cuda.is_available(),
):
    supported_kernel_types = {'fixed', 'adaptive'}
    assert kernel_type in supported_kernel_types
    D = lazy_distance_matrix(X, use_cuda=use_cuda)
    if kernel_type == "fixed":
            # if not sigma:
            #     # estimate sigma using a heuristic
            #     sigma = median_heuristic(D)
            W = (1/(sigma*(2*torch.pi)**(0.5)))*((-D**2)/(2*sigma**2)).exp()
    elif kernel_type == "adaptive":
            raise NotImplementedError("Adaptive kernel runs up against limitations of pykeops...try fixed kernel instead")
            dk = D.Kmin(k, dim=1)[:,-1]
            # Populate matrices with this distance for easy division.
            div1 = LazyTensor(tensor(np.ones(len(X))[:,None]),axis=1) @ LazyTensor(dk[:,None],axis=0)
            div2 = LazyTensor(dk[:,None],axis=1) @ LazyTensor(tensor(np.ones(len(X))[:,None]),axis=0)
            # print("Distance to kth neighbors",distance_to_k_neighbor)
            # compute the gaussian kernel with an adaptive bandwidth
            W = (
                    1/(2*(2*torch.pi)**0.5) * (
                        (-D**2/(2*distance_to_k_neighbor**2)).exp()/distance_to_k_neighbor + 
                        (-D**2/(2*distance_to_k_neighbor**2)).exp()/distance_to_k_neighbor
                    )
                )
    if anisotropic_density_normalization:
        dn = 1/(W.sum(axis=1)**anisotropic_density_normalization)
        W = A / dn[:,None] / dn[None,:]
    return W

# %% ../../nbs/library/Core PyKeops.ipynb 22
def lazy_diffusion_matrix(
    A
):
    """Computes the diffusion matrix from the adjacency matrix A"""
    D = A.sum(axis=1)
    # D = LazyTensor(D)
    return A/D[:,None]

# %% ../../nbs/library/Core PyKeops.ipynb 34
def phate_distances():
    assert G.Pt is not None
    if type(G.Pt) == np.ndarray:
        log_Pts = -np.log(G.Pt + 1e-6)
        D = pairwise_distances(log_Pts)
    elif type(G.Pt) == scipy.sparse.csr_matrix:
        # TODO: There's likely a more efficient way of doing this. 
        # But I mustn't tempt the devil of premature optimization
        Pt_np = G.Pt.toarray()
        log_Pts = -np.log(Pt_np + 1e-6)
        D = pairwise_distances(log_Pts)
    G.D = D
    return G
