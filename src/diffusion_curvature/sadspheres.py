# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/library/datasets/saddle-sphere-ablations.ipynb.

# %% auto 0
__all__ = ['metric', 'SadSpheres']

# %% ../../nbs/library/datasets/saddle-sphere-ablations.ipynb 5
from .core import get_adaptive_graph
from .datasets import rejection_sample_from_saddle, sphere
from fastcore.all import *
import xarray as xr
import inspect
import pandas as pd

import sklearn
import scipy.stats
import numpy as np
import matplotlib.pyplot as plt

def metric(func):
    setattr(func, 'tag', 'metric')
    return func

class SadSpheres():
    def __init__(self,
                 dimension = 2, # Dimension of saddles and spheres
                 num_pointclouds = 100, # num pointclouds to make in total
                 num_points = 2000, # num points per pointclouds
                 noise_level = 0, # from 0 to 1. 1 is all noise.
                ):
        store_attr()
        self.DS = xr.Dataset()
        self.idx = -1
        for i in range(num_pointclouds//2):
            X_saddle, ks_saddle = rejection_sample_from_saddle(self.num_points, self.dimension)
            self.DS[2*i] = xr.DataArray(X_saddle, dims=['n', 'd'], attrs={'ks':ks_saddle})
            X_sphere, ks_sphere = sphere(self.num_points, self.dimension)
            self.DS[2*i+1] = xr.DataArray(X_sphere, dims=['n', 'd'], attrs={'ks':ks_sphere[0]})
    
    def __iter__(self):
        return self

    def __len__(self):
        return self.num_pointclouds

    def __next__(self):
        self.idx += 1
        if self.idx >= self.num_pointclouds:
            raise StopIteration
        result = self.DS[self.idx].to_numpy()
        return result

    def update(self,
               result,
               method_name='computed'):
        """
        Store the result of the curvature computation by passing the computed curvature of the center (first) point.
        """
        self.DS[self.idx].attrs[method_name] = result

    def compute_metrics(self):
        self._aggregate_labels()
        metrics = self._get_metrics()
        self.metric_table = {}
        for metric in metrics:
            self.metric_table[metric.__name__] = {}
            for method_name in self.method_names:
                self.metric_table[metric.__name__][method_name] = self.compute(metric=metric, method_name=method_name)
        self.metric_table = pd.DataFrame(self.metric_table)
            
    def compute(self, metric, method_name):
        # Overwrite this class with your logic. It implements the computation of a single metric for a single method
        return metric(self.labels[method_name], self.labels['ks'])
    

    def _aggregate_labels(self):
        self.method_names = self.DS.data_vars[0].attrs.keys()
        self.labels = {}
        for m in self.method_names:
            self.labels[m] = np.array([self.DS.data_vars[i].attrs[m] for i in range(self.num_pointclouds)])

    def plot(self, title = ""):
        # for each computed method on this dataset, we plot the histogram of saddles vs spheres
        self._aggregate_labels()
        for m in self.method_names: 
            if m != 'ks':
                plt.hist(self.labels[m][0::2], bins=50, color='orange', label = 'Saddles')
                plt.hist(self.labels[m][1::2], bins=50, color='green', label = 'Spheres')
                plt.legend()
                plt.xlabel(m)
                plt.title(f"In dimension {self.dimension}")
                plt.show()

    def table(self):
        self.compute_metrics()
        return self.metric_table

    def _get_metrics(self):
        tagged_functions = []
        for name, member in inspect.getmembers(self, predicate=inspect.ismethod):
            if hasattr(member, 'tag') and getattr(member, 'tag') == 'metric':
                tagged_functions.append(member)
        return tagged_functions

    @metric
    def pearson_r(self, a, b):
        return scipy.stats.pearsonr(a,b)

    @metric
    def sign_score(self, a, b):
        # measures the extent to which the sign of a agrees with b
        return sklearn.metrics.mutual_info_score(
            np.sign(a),
            np.sign(b),
        )
        
    
