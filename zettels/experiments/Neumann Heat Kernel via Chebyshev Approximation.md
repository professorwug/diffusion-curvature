# Analytic estimation of the heat kernel

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

``` html
<style>body {font-family:Baskerville}</style>
```

<style>body {font-family:Baskerville}</style>

## Philosophy

The graph diffusion matrix $P$ is one means of approximating the heat
kernel, which has seen repeated empirical success in methods like
*Diffusion Maps*, *PHATE*, *Diffusion Condensation*, etc. Yet, $P$’s
approximation of heat diffusion is fairly crude. All it does is
normalize the adjacency matrix, which leaves it awfully dependent on how
we parameterize that matrix. A wonky kernel bandwidth or unsatisfactory
density normalization leaves $P$ stranded.

Coifman et al. have proven that $P^t$ converges to the Neumann heat
kernel on the manifold as $t \to 0$, which is to say: *locally*, it’s
perfectly fine. But in practice, $P$ isn’t used with really small powers
of $t$, and the kernel bandwidth is usually large enough that a single
step of diffusion extends haphazardly across the manifold, with decay
determined by unreliable euclidean distances. This can be avoided by
restricting a single step of diffusion to a single neighborhood - but in
this case, powering $P$ to the needed global reach becomes prohibitive.

In this notebook, we implement and experiment with an alternate
estimation of the heat kernel. This was used by Huguet et al’s [A Heat
Diffusion Perspective on Geodesic Preserving Dimensionality
Reduction](https://arxiv.org/abs/2305.19043). The implementation is
adapted from the authors’ source code [KrishnaswamyLab/HeatGeo:
Embedding with the Heat-geodesic
dissimilarity](https://github.com/KrishnaswamyLab/HeatGeo). But,
following Knuth’s guidance on code reuse, we strip it out of the
framework and reimplement the pieces ourselves, to escape ‘dependency
heck’.

## Implementation Outline

------------------------------------------------------------------------

### expm_multiply

>      expm_multiply (L:numpy.ndarray, X:numpy.ndarray, phi:float, tau,
>                     K:int=None, err:float=1e-32)

Computes the exp(tL)X for each t in tau. If L is the graph laplacian,
this is heat diffusion applied to X.

|     | **Type** | **Default** | **Details**                                                                                                                        |
|-----|----------|-------------|------------------------------------------------------------------------------------------------------------------------------------|
| L   | ndarray  |             | The graph laplacian. or another PSD matrix with max eval \<= 2                                                                     |
| X   | ndarray  |             | The signal to diffuse                                                                                                              |
| phi | float    |             | l_max/2, where l_max is the largest eigenvalue of L. PyGSP has a method to compute this easily.                                    |
| tau |          |             | Diffusion times, either as a single float/int, or a list/ndarray of floats/ints                                                    |
| K   | int      | None        | The number of polynomial terms to use in the approximation. If None, calculates the least number that guarantees precision of err. |
| err | float    | 1e-32       | Precision                                                                                                                          |

------------------------------------------------------------------------

### compute_chebychev_coeff_all

>      compute_chebychev_coeff_all (phi, tau, K)

Compute the K+1 Chebychev coefficients for our functions.

------------------------------------------------------------------------

### reverse_bound

>      reverse_bound (f, phi, x, tau, err)

Returns the minimal K such that f(phi, x, tau, K) \<= err.

------------------------------------------------------------------------

### get_bound_bergamaschi_specific

>      get_bound_bergamaschi_specific (phi, x, tau, K)

------------------------------------------------------------------------

### get_bound_bergamaschi_generic

>      get_bound_bergamaschi_generic (phi, x, tau, K)

------------------------------------------------------------------------

### E

>      E (K, C)

------------------------------------------------------------------------

### get_bound_eta_specific

>      get_bound_eta_specific (phi, x, tau, K)

------------------------------------------------------------------------

### get_bound_eta_generic

>      get_bound_eta_generic (phi, x, tau, K)

------------------------------------------------------------------------

### get_bound_eps_generic

>      get_bound_eps_generic (phi, x, tau, K)

------------------------------------------------------------------------

### g

>      g (K, C)

Here’s an example of how to use this.

``` python
from diffusion_curvature.datasets import torus
from diffusion_curvature.graphs import *
```

``` python
X, ks = torus(2000)
G_torus = get_alpha_decay_graph(X)
```

To use `expm_multiply`, we need: 1. The graph laplacian 2. An estimate
of the largest eigenvalue (e.g. from PyGSP) 3. The diffusion times

For convenience, here’s a wrapper that does all of this for a PyGSP
graph and signal.

------------------------------------------------------------------------

### heat_diffusion_on_signal

>      heat_diffusion_on_signal (G:pygsp.graphs.graph.Graph, x:numpy.ndarray, t)

Returns the heat-diffused signal. Uses chebyshev approximation of
exp(-tL).

|     | **Type** | **Details**                         |
|-----|----------|-------------------------------------|
| G   | Graph    | The graph on which to diffuse heat  |
| x   | ndarray  | The signal to diffuse               |
| t   |          | time of diffusion, or list of times |

------------------------------------------------------------------------

### kronecker_delta

>      kronecker_delta (length, idx=None)

returns np array of len with all zeroes except idx.

|        | **Type** | **Default** | **Details**                                                                                  |
|--------|----------|-------------|----------------------------------------------------------------------------------------------|
| length |          |             | length of array. If you pass an array or list, length is set to size of the first dimension. |
| idx    | NoneType | None        | idx to make nonzero. If none, fills a random idx.                                            |

``` python
diffused_diracs = heat_diffusion_on_signal(G_torus,kronecker_delta(X),[4,8,12])
```

``` python
plot_3d(X,diffused_diracs[2])
```

![](Neumann%20Heat%20Kernel%20via%20Chebyshev%20Approximation_files/figure-commonmark/cell-18-output-1.png)

## Estimation of Euclidean heat
