# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/diffusion-trajectory-distance-normalization.ipynb.

# %% auto 0
__all__ = ['diffusion_distances_along_trajectory', 'show_curvature_curves']

# %% ../nbs/diffusion-trajectory-distance-normalization.ipynb 7
from scipy.spatial.distance import jensenshannon
def diffusion_distances_along_trajectory(diffusions):
    # given a sequence of diffusions, returns the distances between each 
    distances = [0]
    for idx in range(len(diffusions)-1):
        distances.append(
            # distances[-1] + np.linalg.norm(
            #     diffusions[idx+1] - diffusions[idx]
            # )
            distances[-1] + jensenshannon(diffusions[idx+1], diffusions[idx])
            
        )
    return np.array(distances)

# %% ../nbs/diffusion-trajectory-distance-normalization.ipynb 9
from functools import partial
import numpy as np
import matplotlib.pyplot as plt
from functools import partial
from fastcore.all import *
from .core import *
from tqdm.auto import tqdm
import inspect

@patch
def curvature_curve(self:DiffusionCurvature, 
                    num_ts=50, 
                    idx = 0, 
                    **kwargs
                    ):    
    curvatures = []
    Pts = []
    t_values = np.arange(1, num_ts+1)
    for t in tqdm(t_values):
        laziness, laziness_nought, P, Pt, t = self.unsigned_curvature(self.G, int(t), _also_return_first_scale=True, **kwargs)
        if len(Pts) == 0: Pts.append(np.eye(len(P))[idx])
        curvatures.append(laziness[idx])
        Pts.append(Pt[idx])
    # compute distances along trajectory
    # distances_along_trajectory = diffusion_distances_along_trajectory(Pts)
    distances_along_trajectory = diffusion_distances_along_trajectory(Pts)[1:]
    curvatures = np.array(curvatures)
    return t_values, distances_along_trajectory, curvatures

def show_curvature_curves(*diffusion_curvatures, num_ts=50, idx=0, scaling_fn=None, title="Curvature Curves", **kwargs):
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    for dc in diffusion_curvatures:
        dc_name = None
        for frame_record in inspect.stack():
            frame = frame_record.frame
            for name, obj in frame.f_globals.items():
                if obj is dc:
                    dc_name = name
            for name, obj in frame.f_locals.items():
                if obj is dc:
                    dc_name = name
        if dc_name is None:
            dc_name = "Unknown"
        
        t_values, distances, curvatures = dc.curvature_curve(num_ts=num_ts, idx=idx, **kwargs)
        axs[0].plot(distances, curvatures, label=dc_name)
        axs[1].plot(t_values, curvatures, label=dc_name)
        
    axs[0].set_title("Spread of diffusion vs distance along diffusion trajectory")
    axs[1].set_title("Spread of diffusion vs time")
    axs[1].set_xlabel('Time ($t$)')    
    axs[1].set_ylabel('Spread of diffusion')
    axs[0].set_xlabel('Distance')
    axs[0].set_ylabel('Spread of diffusion')
    fig.suptitle(title)
    axs[0].legend()
    axs[1].legend()
    plt.show()
