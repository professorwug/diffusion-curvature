# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/0a0-Kernels.ipynb.

# %% auto 0
__all__ = ['median_heuristic', 'gaussian_kernel', 'compute_anisotropic_affinities_from_graph',
           'compute_anisotropic_diffusion_matrix_from_graph', 'pygsp_graph_from_points', 'SimpleGraph',
           'get_curvature_agnostic_graph', 'get_adaptive_graph', 'get_fixed_graph', 'get_knn_graph', 'diffusion_matrix',
           'diffusion_matrix_from_affinities', 'diffusion_matrix_from_graph', 'num_in_first_scale_of_diffusion',
           'tune_curvature_agnostic_kernel']

# %% ../nbs/0a0-Kernels.ipynb 7
import numpy as np
def median_heuristic(
        D:np.ndarray, # the distance matrix
):
    # estimate kernel bandwidth from distance matrix using the median heuristic
    # Get upper triangle from distance matrix (ignoring duplicates)
    h = D[np.triu_indices_from(D)]
    h = h**2
    h = np.median(h)
    nu = np.sqrt(h / 2)
    return nu

# %% ../nbs/0a0-Kernels.ipynb 8
import numpy as np
from sklearn.metrics import pairwise_distances
def gaussian_kernel(
        X:np.ndarray, # pointcloud data as rows, shape n x d
        kernel_type = "fixed", # either fixed, or adaptive
        sigma:float = 0, # if fixed, uses kernel bandwidth sigma. If not set, uses a heuristic to estimate a good sigma value
        k:float = 10, # if adaptive, creates a different kernel bandwidth for each point, based on the distance from that point to the kth nearest neighbor
        anisotropic_density_normalization:float = 0.5, # if nonzero, performs anisotropic density normalization
        threshold_for_small_values:float = 1e-5, # Sets all affinities below this value to zero. Set to zero to disable.
        neighbor_scale:float = 3.0, # if curvature agnostic, this is the scale of the neighbor distance
):
    """Constructs an affinity matrix from pointcloud data, using a gaussian kernel"""
    supported_kernel_types = {'fixed', 'adaptive', 'curvature agnostic'}
    assert kernel_type in supported_kernel_types
    D = pairwise_distances(X)
    if kernel_type == "fixed":
        if not sigma:
            # estimate sigma using a heuristic
            sigma = median_heuristic(D)
        W = (1/(sigma*np.sqrt(2*np.pi)))*np.exp((-D**2)/(2*sigma**2))
    elif kernel_type == "adaptive":
        distance_to_k_neighbor = np.partition(D,k)[:,k]
        # Populate matrices with this distance for easy division.
        div1 = np.ones(len(D))[:,None] @ distance_to_k_neighbor[None,:]
        div2 = distance_to_k_neighbor[:,None] @ np.ones(len(D))[None,:]
        # print("Distance to kth neighbors",distance_to_k_neighbor)
        # compute the gaussian kernel with an adaptive bandwidth
        W = (1/(2*np.sqrt(2*np.pi)))*(np.exp(-D**2/(2*div1**2))/div1 + np.exp(-D**2/(2*div2**2))/div2)
    elif kernel_type == "curvature agnostic":
        scaled_neighbor_dists = np.partition(D,k)[:,k]  # TODO is multiplication best here?
        sigma = np.mean(scaled_neighbor_dists) * neighbor_scale
        W = np.exp((-D**2)/sigma**2)
        # div1 = np.ones(len(D))[:,None] @ scaled_neighbor_dists[None,:]
        # div2 = scaled_neighbor_dists[:,None] @ np.ones(len(D))[None,:]
        # W = (1/(2*np.sqrt(2*np.pi)))*(np.exp(-D**2/(2*div1**2))/div1 + np.exp(-D**2/(2*div2**2))/div2)
    if anisotropic_density_normalization:
        D = np.diag(1/(np.sum(W,axis=1)**anisotropic_density_normalization))
        W = D @ W @ D
    if threshold_for_small_values:
        W[W < threshold_for_small_values] = 0
    return W

# %% ../nbs/0a0-Kernels.ipynb 9
import numpy as np
def compute_anisotropic_affinities_from_graph(
    W:np.ndarray, # the adjacency/affinity matrix of the graph
    alpha:float, # the anisotropic density normalization parameter
) -> np.ndarray:
    # normalize by density
    D = np.diag(1/(np.sum(W,axis=1)**alpha))
    W = D @ W @ D
    return W

def compute_anisotropic_diffusion_matrix_from_graph(
    A:np.ndarray, # the adjacency/affinity matrix of the graph
    alpha:float, # the anisotropic density normalization parameter
    ) -> np.ndarray:
    A_anis = compute_anisotropic_affinities_from_graph(A,alpha)
    # row normalize to create diffusion matrix
    D = np.diag(1/(np.sum(A_anis,axis=1)+1e-8))
    P = D @ A_anis
    return P

# %% ../nbs/0a0-Kernels.ipynb 10
import pygsp
def pygsp_graph_from_points(X, knn=15):
    W = gaussian_kernel(X, kernel_type="adaptive", k=knn, anisotropic_density_normalization=1)
    G = pygsp.graphs.Graph(W)
    return G

# %% ../nbs/0a0-Kernels.ipynb 11
from dataclasses import dataclass
import warnings

@dataclass
class SimpleGraph:
    W: np.ndarray


def get_curvature_agnostic_graph(X, neighbor_scale = 1, k = 1, alpha = 0, self_loops = True, simple_graph = True):
    W = gaussian_kernel(
        X, 
        kernel_type = "curvature agnostic", 
        k = k, 
        neighbor_scale=neighbor_scale, 
        anisotropic_density_normalization = alpha,
    )
    # set diagonal of W to zero
    if not self_loops: np.fill_diagonal(W, 0)
    if simple_graph:
        G = SimpleGraph(W)
    else:
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            G = pygsp.graphs.Graph(W)
    return G
    

def get_adaptive_graph(X, k = 5, alpha = 1, self_loops = True):
    W = gaussian_kernel(
        X,
        kernel_type='adaptive',
        k = k,
        anisotropic_density_normalization = alpha,
    )
    if not self_loops: np.fill_diagonal(W, 0)
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=UserWarning, module='pygsp')
        G = pygsp.graphs.Graph(W)
    return G

def get_fixed_graph(X, sigma = 0.2, alpha = 1, self_loops = True):
    W = gaussian_kernel(
        X, 
        kernel_type = "fixed",
        sigma = sigma,
        anisotropic_density_normalization = alpha,
    )
    # set diagonal of W to zero
    if not self_loops: np.fill_diagonal(W, 0)
    with warnings.catch_warnings():
        warnings.filterwarnings("ignore", category=UserWarning, module='pygsp')
        G = pygsp.graphs.Graph(W)
    return G

# %% ../nbs/0a0-Kernels.ipynb 17
from sklearn.neighbors import kneighbors_graph
def get_knn_graph(
        X:np.ndarray,
        k = 10,
        alpha = 1,
        use_pygsp = True,
        self_loops = True
):
    W = kneighbors_graph(X, k, mode='connectivity', include_self=self_loops).toarray()
    if alpha > 0:
        W = compute_anisotropic_affinities_from_graph(W, alpha)
    if use_pygsp:
        G = pygsp.graphs.Graph(W)
        return G
    else:
        return W

# %% ../nbs/0a0-Kernels.ipynb 20
import numpy as np
from sklearn.metrics import pairwise_distances
from sklearn.preprocessing import normalize
from graphtools.matrix import set_diagonal

def diffusion_matrix(
        X:np.ndarray = None, # pointcloud data
        A:np.ndarray = None, # adjacency matrix, if precomputed
        kernel_type:str = "fixed", # either fixed or adaptive
        sigma = 0, # if fixed, uses kernel bandwidth sigma. If not set, uses a heuristic to estimate a good sigma value
        k = 10, # if adaptive, creates a different kernel bandwidth for each point, based on the distance from that point to the kth nearest neighbor
        anisotropic_density_normalization = 0.5, # if nonzero, performs anisotropic density normalization
        threshold_for_small_values = 1e-5,
):
    """ Creates a diffusion matrix from pointcloud data, by row-normalizing the affinity matrix obtained from the gaussian_kernel function """
    if X is not None:
        W = gaussian_kernel(X,kernel_type,sigma=sigma,k = k,anisotropic_density_normalization = anisotropic_density_normalization, threshold_for_small_values=threshold_for_small_values)
        W = W + np.eye(len(X))*1e-5
    if X is None and A is not None:
        W = A
    
    K = set_diagonal(W, 1)
    P = normalize(W, norm="l1", axis=1)
    return P

# %% ../nbs/0a0-Kernels.ipynb 21
import jax.numpy as jnp
def diffusion_matrix_from_affinities(
        W
):
    W = W + jnp.eye(len(W))*1e-8
    D = jnp.diag(1/jnp.sum(W,axis=1))
    P = D @ W
    return P

def diffusion_matrix_from_graph(
        G
):
    return diffusion_matrix_from_affinities(G.W)

# %% ../nbs/0a0-Kernels.ipynb 56
import jax
from functools import partial

@jax.jit
def num_in_first_scale_of_diffusion(
        P:jax.Array, # diffusion matrix
        eps:float = 1e-10, # only counts points with diffusion mass greater than this
):
    P_e = (P > eps).astype(int)
    nums = jnp.sum(P_e, axis=1)
    return jnp.median(nums) # the median is hopefully more robust to outlier points in really dense pockets.

# %% ../nbs/0a0-Kernels.ipynb 57
import warnings
def tune_curvature_agnostic_kernel(X:np.ndarray, num_in_first_scale:int, tolerance:int = 5, eps:float = 1e-10, max_iterations = 1000, **kwargs):
        def try_kernel_with_neighbor_scale(X, ns, **kwargs):
                kernel = partial(get_curvature_agnostic_graph, neighbor_scale = ns, **kwargs)
                G = kernel(X)
                P = diffusion_matrix_from_graph(G)
                num = num_in_first_scale_of_diffusion(P, eps)
                return num, kernel
        
        lower_bound = 0
        upper_bound = 10
        best_ns = None
        best_num = float('inf')
        total_runs = 0
        
        while abs(best_num - num_in_first_scale) > tolerance and total_runs < max_iterations:
                total_runs += 1
                ns = (lower_bound + upper_bound) / 2
                num, kernel = try_kernel_with_neighbor_scale(X, ns, **kwargs)
                num = num.item()
                
                if num > num_in_first_scale:
                        upper_bound = ns
                else:
                        lower_bound = ns
                
                if abs(num - num_in_first_scale) < abs(best_num - num_in_first_scale):
                        best_ns = ns
                        best_num = num
        if total_runs >= max_iterations and abs(best_num - num_in_first_scale) > tolerance:
            warnings.warn(f"Kernel bandwidth selection did not converge. Desired {num_in_first_scale} pts. in first diffusion but only found {best_num}.")
        
        _, best_kernel = try_kernel_with_neighbor_scale(X, best_ns)
        return best_kernel, best_ns

