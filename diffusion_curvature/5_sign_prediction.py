# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/5-sign-prediction-tests.ipynb.

# %% auto 0
__all__ = ['dims', 'num_pointclouds', 'objective', 'optimize_parameters']

# %% ../nbs/5-sign-prediction-tests.ipynb 15
import optuna
import os
import math
import numpy as np
import time
from fastcore.all import *
from nbdev.showdoc import *

## Imports for plotting
import matplotlib.pyplot as plt
from IPython.display import set_matplotlib_formats
# set_matplotlib_formats('svg', 'pdf') # For export
from matplotlib.colors import to_rgba
import seaborn as sns
sns.set()

## Progress bar
from tqdm.auto import tqdm, trange

from functools import partial

## project specifics
import diffusion_curvature
import pygsp
import jax
import jax.numpy as jnp
from .graphs import *
from .datasets import *
from .core import *
from .utils import *
# from diffusion_curvature.comparison_space import *
from .sadspheres import *
from .kernels import *

dims = [2, 3, 4, 5, 6]
num_pointclouds = 3

# Define the objective function for Optuna
def objective(trial):
    # Define the hyperparameter search space
    params = {
        'laziness_method': trial.suggest_categorical('laziness_method', ['Entropic']),
        'anisotropy': trial.suggest_float('anisotropy', 0, 1, step = 0.1),
        'k' : trial.suggest_int('k', 1, 10),
        'neighbor_scale': trial.suggest_int('neighbor_scale', 1, 20),
        'max_t':trial.suggest_int('max_t', 10, 100)
    }

    SS1 = SadSpheres(
        dimension = dims, # Dimension of saddles and spheres
        num_pointclouds = num_pointclouds, # num pointclouds to make in total
        num_points = 2000, # num points per pointclouds
        noise_level = 0, # from 0 to 1. 1 is all noise.
        include_planes=True,
    )
    print("index is ", SS1.idx)
    for X in tqdm(SS1):
        DC = DiffusionCurvature2(
            graph_former = partial(get_curvature_agnostic_graph, 
                                   k = params['k'], 
                                   neighbor_scale = params['neighbor_scale'], 
                                   alpha=params['anisotropy'], 
                                   self_loops=True)
        )
        ks = DC.fit(X, dim = X.shape[1] - 1, idx = 0, ts = list(range(1,params['max_t'])))
        SS1.update(ks.item(), method_name = "Diffusion Curvature 2 Optuna")
    score = SS1.get_score('Diffusion Curvature 2 Optuna', 'pearson_r')
    
    SS1.delete_saved_method('Diffusion Curvature 2 Optuna')
    return score


@call_parse
def optimize_parameters():
    # Create a study object and specify TPE as the sampler
    study = optuna.create_study(direction='maximize', sampler=optuna.samplers.TPESampler())
    study.optimize(objective, n_trials=50)
    
    # Print the best hyperparameters and the best score
    print("Best hyperparameters: ", study.best_params)
    print("Best score: ", study.best_value)
