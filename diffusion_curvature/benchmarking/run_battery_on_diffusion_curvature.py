# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb.

# %% auto 0
__all__ = ['battery_file', 'k', 'neighbor_scale', 'alpha', 'ts', 'name_of_run', 'curvature_fn', 'main', 'compute_correlations',
           'result_table', 'compute_sign_score']

# %% ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb 3
# parameters for run
battery_file = "/home/piriac/data/diffusion_curvature/Curvature_Colosseum_dikey.h5"
# battery_file = "/home/piriac/data/diffusion_curvature/Curvature_Colosseum_LowD_HighSampled.h5" # for test runs
k = 80 # for curvature agnostic kernel
neighbor_scale = 2 # for curvature agnostic kernel
alpha = 0
ts = list(range(1,80))

name_of_run = f"DC2_with_idx_k-{k}_alpha-{alpha}_maxt-{max(ts)}"
print(name_of_run)

# %% ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb 5
from ..core import DiffusionCurvature2
from ..kernels import get_curvature_agnostic_graph, tune_curvature_agnostic_kernel

def curvature_fn(X, dim, k = k, ts = ts, alpha = alpha, ns = neighbor_scale):
    graph_former, ns = tune_curvature_agnostic_kernel(X, k, tolerance = 1, max_iterations = 100, alpha = alpha)
    # graph_former = partial(get_curvature_agnostic_graph, k = k, neighbor_scale = neighbor_scale, alpha = alpha)
    DC = DiffusionCurvature2(
        diffusion_type = "diffusion matrix",
        laziness_method="Entropic",
        comparison_method="Subtraction",
        graph_former = graph_former,
    )
    k = DC.fit(
        X, dim, ts = ts, idx = 0
    )
    return k.item()

# %% ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb 6
from ..utils import jax_set_best_gpu
from tqdm.auto import tqdm, trange
from .curvature_colosseum import compute_curvature_on_battery
from fastcore.all import *
import deepdish

@call_parse
def main():
    jax_set_best_gpu()
    # load curvature battery
    CC = deepdish.io.load(battery_file)

    saved_calcs = f"/home/piriac/data/diffusion_curvature/computed_diffusion_curvatures_core_{name_of_run}.h5"
    if os.path.exists(saved_calcs):
        print(f"Loading saved calculations from {saved_calcs}")
        computed_curvatures= deepdish.io.load(saved_calcs)
    else:
        computed_curvatures = compute_curvature_on_battery(curvature_fn, CC)
        deepdish.io.save(f"/home/piriac/data/diffusion_curvature/computed_diffusion_curvatures_core_{name_of_run}.h5", computed_curvatures)
    return CC, computed_curvatures

# %% ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb 10
# compute the pearson correlations between the computed curvature and the true curvature
def compute_correlations(
        computed_curvature, # the computed curvature
        CC, # the battery dictionary
        ):
    correlations = {}
    for d in tqdm(CC['dims'], desc="intrinsic dimensions"):
        correlations[d] = {}
        for c in tqdm(CC[d]['codims'], leave=False, desc='codimensions'):
            correlations[d][c] = {}
            for noise_level in tqdm(CC[d][c]['noise_levels'], leave=False, desc="Noise Levels"):
                correlations[d][c][noise_level] = {}
                correlations[d][c][noise_level]['r'] = []
                correlations[d][c][noise_level]['p'] = []
                # for i in trange(len(CC[d][c][noise_level]['Xs']), leave=False, desc="Samples"):
                k = computed_curvature[d][c][noise_level]['k']
                k_true = CC[d][c][noise_level]['k']
                r, p = pearsonr(k, k_true)
                correlations[d][c][noise_level]['r'] = r
                correlations[d][c][noise_level]['p'] = p
    return correlations

# %% ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb 13
# Make a latex table of the correlations, both r and p values, with dimension in the rows and noise level in the columns
def result_table(
        correlations, # dictionary of correlations
        c:int, # codimension
        style = 'fancy_grid',
        keys = ['r','p']
        ):
    noise_levels = correlations[correlations.keys().__iter__().__next__()][c].keys()
    print("Codimension = ",c)
    table = tabulate(
        [[d] + [f"{correlations[d][c][noise_level][keys[0]]:.{3}f}{'/' + str(correlations[d][c][noise_level][keys[1]])[:4] if len(keys) > 1 else ''}" for noise_level in noise_levels] for d in correlations.keys()],
        headers=['dim'] + [f"Noise = {nl}" for nl in noise_levels],
        tablefmt=style, #latex_raw
        floatfmt=".2f",
        )
    print(table)
    return table

# %% ../../nbs/4a-curvature-colosseum-with-diffusion-curvature.ipynb 19
def compute_sign_score(
        computed_curvature, # the computed curvature
        CC, # the battery dictionary
        ):
    correlations = {}
    for d in tqdm(CC['dims'], desc="intrinsic dimensions"):
        correlations[d] = {}
        for c in CC[d]['codims']:
            correlations[d][c] = {}
            for noise_level in tqdm(CC[d][c]['noise_levels'], leave=False, desc="Noise Levels"):
                correlations[d][c][noise_level] = {}
                correlations[d][c][noise_level]['r'] = []
                correlations[d][c][noise_level]['p'] = []
                # for i in trange(len(CC[d][c][noise_level]['Xs']), leave=False, desc="Samples"):
                k = computed_curvature[d][c][noise_level]['k']
                k_true = CC[d][c][noise_level]['k']
                # measure the 'classification accuracy' of the signs.
                class_acc = np.sum(
                    (np.sign(k) == np.sign(k_true)).astype(int)
                ) / len(k)
                correlations[d][c][noise_level]['accuracy'] = class_acc
    return correlations
