# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/5-sign-prediction-tests.ipynb.

# %% auto 0
__all__ = ['dims', 'num_pointclouds', 'method_name', 'run_sadspheres', 'objective', 'optimize_parameters', 'main']

# %% ../../nbs/5-sign-prediction-tests.ipynb 4
dims = [2, 3, 4, 5, 6]
num_pointclouds = 20

# %% ../../nbs/5-sign-prediction-tests.ipynb 5
from tqdm.auto import tqdm, trange
from fastcore.all import *
import diffusion_curvature
import pygsp
import jax
import jax.numpy as jnp
from ..graphs import *
from ..datasets import *
from ..core import *
from ..utils import *
# from diffusion_curvature.comparison_space import *
from ..sadspheres import *
from ..kernels import *
from ..kernels import tune_curvature_agnostic_kernel

method_name = "Diffusion Curvature (Locality Scale 2 - No Denoising - 10 trials)"

def run_sadspheres(
):
    SS1 = SadSpheres(
        dimension = dims, # Dimension of saddles and spheres
        num_pointclouds = num_pointclouds, # num pointclouds to make in total
        num_points = 2000, # num points per pointclouds
        noise_level = 0, # from 0 to 1. 1 is all noise.
        include_planes=True,
    )
    known_dim_bandwidths = {}
    if method_name in SS1.imported_methods:
        return SS1
    for X in tqdm(SS1):
        dim = X.shape[1] - 1
        if dim not in known_dim_bandwidths.keys():
            kernel, ns = tune_curvature_agnostic_kernel(X, 120, tolerance = 5, max_iterations = 100, alpha = 0)
            known_dim_bandwidths[dim] = kernel
        DC = DiffusionCurvature2(
            graph_former = known_dim_bandwidths[dim],
            comparison_space_trials = 3,
            smoothing = None,
        )
        ks = DC.fit(X, dim = X.shape[1] - 1, ts = list(range(1,40)), locality_scale = 0.9, idx = 0)
        SS1.update(ks.item(), method_name = method_name)
    SS1.save_results()
    return SS1

# %% ../../nbs/5-sign-prediction-tests.ipynb 14
import optuna
import os
import math
import numpy as np
import time
from fastcore.all import *
from nbdev.showdoc import *

## Imports for plotting
import matplotlib.pyplot as plt
from IPython.display import set_matplotlib_formats
# set_matplotlib_formats('svg', 'pdf') # For export
from matplotlib.colors import to_rgba
import seaborn as sns
sns.set()

## Progress bar
from tqdm.auto import tqdm, trange

from functools import partial

## project specifics
import diffusion_curvature
import pygsp
import jax
import jax.numpy as jnp
from ..graphs import *
from ..datasets import *
from ..core import *
from ..utils import *
# from diffusion_curvature.comparison_space import *
from ..sadspheres import *
from ..kernels import *

dims = [2, 3, 4, 5, 6]
num_pointclouds = 20

# Define the objective function for Optuna
def objective(trial):
    # Define the hyperparameter search space
    params = {
        # 'laziness_method': trial.suggest_categorical('laziness_method', ['Entropic']),
        'anisotropy': trial.suggest_float('anisotropy', 0, 1, step = 0.1),
        # 'k' : trial.suggest_int('k', 1, 10),
        # 'neighbor_scale': trial.suggest_int('neighbor_scale', 1, 20),
        'max_t':trial.suggest_int('max_t', 10, 100),
        'size_of_first_scale': trial.suggest_int('size_of_first_scale', 3, 50),
        'tolerance': trial.suggest_int('tolerance',1, 10),
    }

    SS1 = SadSpheres(
        dimension = dims, # Dimension of saddles and spheres
        num_pointclouds = num_pointclouds, # num pointclouds to make in total
        num_points = 2000, # num points per pointclouds
        noise_level = 0, # from 0 to 1. 1 is all noise.
        include_planes=True,
    )
    print("index is ", SS1.idx)
    for X in tqdm(SS1):
        kernel, ns = tune_curvature_agnostic_kernel(X, params['size_of_first_scale'], tolerance = params['tolerance'], max_iterations = 100, alpha = params['anisotropy'])
        DC = DiffusionCurvature2(
            graph_former = kernel
        )
        ks = DC.fit(X, dim = X.shape[1] - 1, idx = 0, ts = list(range(1,params['max_t'])))
        SS1.update(ks.item(), method_name = "Diffusion Curvature 2 Optuna")
    score = SS1.get_score('Diffusion Curvature 2 Optuna', 'sign_score')
    
    SS1.delete_saved_method('Diffusion Curvature 2 Optuna')
    SS1.save_results()
    return score


def optimize_parameters():
    # Create a study object and specify TPE as the sampler
    study = optuna.create_study(direction='maximize', sampler=optuna.samplers.TPESampler())
    study.optimize(objective, n_trials=50)
    
    # Print the best hyperparameters and the best score
    print("Best hyperparameters: ", study.best_params)
    print("Best score: ", study.best_value)

# %% ../../nbs/5-sign-prediction-tests.ipynb 16
@call_parse
def main(
    search_parameters = False
):
    if search_parameters:
        optimize_parameters()
    else:
        run_sadspheres()
